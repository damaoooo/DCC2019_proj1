# 项目二文件结构

```
|-- Python 项目二
	|-- Unit 网元
		|-- tcpLayer网络层
			checkXor(str:text)->bool:res
		|-- dataLayer 数据链路层
			|-- wrapFrame(rawFrames)->list:Frames
			|-- parseFrame(recvFrames)->list:checkedFrames
	|-- method 方法
		|--Oddcheck(list:Frames)->list:result[[row],[crowd]]
		|--bytes2Bin(bytestr:bytes)->str:rawBin
		|--bin2Frames(str:bindata,mode)->list:Frames//mode->1.encode 2.decode
		|--frames2Bin(list:Frames)->str:rawBin
		|--bin2Bytes(str:rawBin)->bytes:bytes
		|--text2Bytes(str:bytes)->str:bytes
		|--addXorCheck(str:text)->str:text
```

## 设计

按帧传输一帧8\*8 bit + 2\*8校验位 = 80bit，二维奇偶校验

或者是采用16\*16+2*16 = 288bit，由于UTF-8编码问题有ASCII字符是8bit，所以就可能会出现只有8bit而不是16bit，就采用在最后面加入8个0的方式进行区分

层与层之间直接采用List的方式传帧，[[],[],[]]的方式

数据链路层：

text->text2Bytes()->bytes2Bin()->bin2Frames()->Frame->oddcheck->bin->bytes->send

recv->bin->Frame->oddcheck()->checkXor()->Frame2bin()->bin2bytes()->bytes2text()

网络层：

sender: send->recv->send

recver : recv->send : ack->recv()

---



## 发送过程

根据误码率20/100000，传输5000个错1个，所以按照288为一帧太不划算，而且帧这个应该是在网络层包装，网络层中的极限数据bit位是4000个，我们就取3200个,也就是400字节（测试用例根本取不到）

'10110111'-->8bit为1字节

### 网络层

数据`hello world!你好啊嘤嘤嘤`

#### ----转化为bytes流---->

`b'hello world!\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x95\x8a\xe5\x98\xa4\xe5\x98\xa4\xe5\x98\xa4'`

#### ----加入帧编号0-a---->

`b'\x01hello world!\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x95\x8a\xe5\x98\xa4\xe5\x98\xa4\xe5\x98\xa4'`

#### ----转化为2进制字符串---->

'101010101010101010101010101......10101010'

#### ----按照8bit来分成字节，然后过长则分帧---->

[['11111111','11111111','11111111',......(最多386个字节单元)......,'11111111'],

['11111111','11111111','11111111',......(最多386个字节单元)......,'11111111'],

['11111111','11111111','11111111',......(最多386个字节单元)......,'11111111'],

........

['11111111','11111111','11111111',......(最多386个字节单元)......,'11111111']]

#### ----添加头尾部---->

帧编号:`00-0f`,1字节

源IP:`ff.ff.ff.ff`,4字节，源端口:`ffff`，2字节

目的IP:`ff.ff.ff.ff`，4字节，目的端口:`ffff`,2字节

尾部：所有字节全部XOR一次，结果1字节

头部尾部算上一共要添加14字节

#### ----发送一个帧到数据链路层---->

### 数据链路层

['11111111','11111111','11111111',......,'11111111']

#### ----分帧---->

[['11111111','11111111'....(8个字节)......'11111111'],

['11111111','11111111'....(8个字节)......'11111111'],

............

['11111111','11111111'....(8个字节)......]]

其中[[],[],[],[]]为一个帧，里面的['111111','10101010',...（8个bit）...,'11100011']称为一个**校验单元**

#### ----二维奇偶校验---->

[['11111111','10101010'....(10个字节，8字节数据，2字节校验)........'11111111'],

['11111111','10101010'....(10个字节，8字节数据，2字节校验)........'11111111'],

['11111111','10101010'....(10个字节，8字节数据，2字节校验)........'11111111'],

['11111111','10101010'....(10个字节，8字节数据，2字节校验)........'11111111']]

#### ----转化为bytes流---->

`\xef\xab\x0c\xc0......\xab\x3a`

#### ----前后加上`\xee\xff`作为帧开始符，加上`\xff\xee`作为结束符---->

`\xee\xff\xef\xab\x0c\xc0......\xab\x3a\xff\xee`

#### ----发送---->

---

## 接收过程

